<!DOCTYPE html>
  
  
  
  
   <html class="no-js"> 

  <head lang="pt-br">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=10" />
    <title>Mapas - R Sociais</title>
    <meta name="generator" content="Hugo 0.22" />

    
    <meta name="description" content="Material do Curso de Programação para Ciências Sociais">
    
    <link rel="canonical" href="../tutorial8/">
    
    <meta name="author" content="Curso de Programação para Ciências Sociais">
    

    <meta property="og:url" content="/tutorial8/">
    <meta property="og:title" content="R Sociais">
    <meta property="og:image" content="/logo_r4sc.jpg">
    <meta name="apple-mobile-web-app-title" content="R Sociais">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <link rel="shortcut icon" type="image/x-icon" href="../images/favicon.ico">
    <link rel="icon" type="image/x-icon" href="../images/favicon.ico">

    <style>
      @font-face {
        font-family: 'Icon';
        src: url('/fonts/icon.eot');
        src: url('/fonts/icon.eot')
               format('embedded-opentype'),
             url('/fonts/icon.woff')
               format('woff'),
             url('/fonts/icon.ttf')
               format('truetype'),
             url('/fonts/icon.svg')
               format('svg');
        font-weight: normal;
        font-style: normal;
      }
    </style>

    <link rel="stylesheet" href="../stylesheets/application.css">
    <link rel="stylesheet" href="../stylesheets/temporary.css">
    <link rel="stylesheet" href="../stylesheets/palettes.css">
    <link rel="stylesheet" href="../stylesheets/highlight/highlight.css">

    
    
    
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ubuntu:400,700|Ubuntu&#43;Mono">
    <style>
      body, input {
        font-family: 'Ubuntu', Helvetica, Arial, sans-serif;
      }
      pre, code {
        font-family: 'Ubuntu Mono', 'Courier New', 'Courier', monospace;
      }
    </style>

    
    <script src="../javascripts/modernizr.js"></script>

    

  </head>
  <body class="palette-primary-red palette-accent-teal">



	
	


<div class="backdrop">
	<div class="backdrop-paper"></div>
</div>

<input class="toggle" type="checkbox" id="toggle-drawer">
<input class="toggle" type="checkbox" id="toggle-search">
<label class="toggle-button overlay" for="toggle-drawer"></label>

<header class="header">
	<nav aria-label="Header">
  <div class="bar default">
    <div class="button button-menu" role="button" aria-label="Menu">
      <label class="toggle-button icon icon-menu" for="toggle-drawer">
        <span></span>
      </label>
    </div>
    <div class="stretch">
      <div class="title">
        Mapas
      </div>
    </div>

    

    
    <div class="button button-github" role="button" aria-label="GitHub">
      <a href="https://github.com/R4CS" title="@R4CS on GitHub" target="_blank" class="toggle-button icon icon-github"></a>
    </div>
    
    
        
  </div>
  <div class="bar search">
    <div class="button button-close" role="button" aria-label="Close">
      <label class="toggle-button icon icon-back" for="toggle-search"></label>
    </div>
    <div class="stretch">
      <div class="field">
        <input class="query" type="text" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck>
      </div>
    </div>
    <div class="button button-reset" role="button" aria-label="Search">
      <button class="toggle-button icon icon-close" id="reset-search"></button>
    </div>
  </div>
</nav>
</header>

<main class="main">
	<div class="drawer">
		<nav aria-label="Navigation">
  <a href="https://github.com/R4CS/site" class="project">
    <div class="banner">
      
        <div class="logo">
          <img src="../logo_r4sc.jpg">
        </div>
      
      <div class="name">
        <strong>R Sociais </strong>
        
          <br>
          R4CS/site
        
      </div>
    </div>
  </a>

  <div class="scrollable">
    <div class="wrapper">
      
        <ul class="repo">
          <li class="repo-download">
            <a href="https://github.com/R4CS/site/archive/master.zip" target="_blank" title="Download" data-action="download">
              <i class="icon icon-download"></i> Download
            </a>
          </li>
          <li class="repo-stars">
            <a href="https://github.com/R4CS/site/stargazers" target="_blank" title="Stargazers" data-action="star">
              <i class="icon icon-star"></i> Stars
              <span class="count">&ndash;</span>
            </a>
          </li>
        </ul>
        <hr>
      

      <div class="toc">
        
        <ul>
          




<li>
  
    



<a  title="Tutorial 1" href="../tutorial1/">
	
	Tutorial 1
</a>



  
</li>



<li>
  
    



<a  title="Tutorial 2" href="../tutorial2/">
	
	Tutorial 2
</a>



  
</li>



<li>
  
    



<a  title="Tutorial 3" href="../tutorial3/">
	
	Tutorial 3
</a>



  
</li>



<li>
  
    



<a  title="Tutorial 4" href="../tutorial4/">
	
	Tutorial 4
</a>



  
</li>



<li>
  
    



<a  title="Tutorial 5" href="../tutorial5/">
	
	Tutorial 5
</a>



  
</li>



<li>
  
    



<a  title="Tutorial 6" href="../tutorial6/">
	
	Tutorial 6
</a>



  
</li>



<li>
  
    



<a  title="Tutorial 7" href="../tutorial7/">
	
	Tutorial 7
</a>



  
</li>



<li>
  
    



<a class="current" title="Tutorial 8" href="../tutorial8/">
	
	Tutorial 8
</a>


<ul id="scrollspy">
</ul>


  
</li>



<li>
  
    



<a  title="Tutorial 9" href="../tutorial9/">
	
	Tutorial 9
</a>



  
</li>



<li>
  
    



<a  title="Tutorial 10" href="../tutorial10/">
	
	Tutorial 10
</a>



  
</li>



<li>
  
    



<a  title="Tutorial 11" href="../tutorial11/">
	
	Tutorial 11
</a>



  
</li>



<li>
  
    



<a  title="Tutorial 12" href="../tutorial12/">
	
	Tutorial 12
</a>



  
</li>



<li>
  
    



<a  title="Tutorial 13" href="../tutorial13/">
	
	Tutorial 13
</a>



  
</li>


        </ul>
        

        
        <hr>
        <span class="section">The author</span>
        
        <ul>
          

          
          <li>
            <a href="https://github.com/R4CS" target="_blank" title="@R4CS on GitHub">
              @R4CS on GitHub
            </a>
          </li>
          

          
          <li>
            <a href="mailto:programacao.sociais@gmail.com" title="Email of programacao.sociais@gmail.com">
              Contact via email
            </a>
          </li>
          
        </ul>
        
      </div>
    </div>
  </div>
</nav>

	</div>

	<article class="article">
		<div class="wrapper">
			<h1>Mapas </h1>

			

<p>Data frames foram, até este momento do curso, o protagonista de nossa análise de dados. Vimos como manipular dados que estão sempre no mesmo formato</p>

<h2 id="informação-espacial-armazenada-em-data-frames-pontos-no-google-maps">Informação espacial armazenada em data frames - pontos no google maps</h2>

<p>Vamos começar a trabalhar com mapas a partir de um exemplo que, veremos, utilizará as ferramentas que aprendemos até então para produzir nossos primeiros mapas. Para tanto, vamos utilizar o cadastro de escolas que a Prefeitura Municipal de São Paulo disponibiliza <a href="http://dados.prefeitura.sp.gov.br/">aqui</a>.</p>

<p>Nossa primeira tarefa é baixar os dados e faremos isso de forma inteligente e sem &ldquo;cliques&rdquo;. A partir do url do arquivo do cadastro, que guardaremos no objeto &ldquo;url_cadatros_escolas&rdquo;, faremos o download do arquivo e guardaremos o arquivo .csv baixado como o nome &ldquo;temp.csv&rdquo;:</p>

<pre><code class="language-r">url_cadatros_escolas &lt;- &quot;http://dados.prefeitura.sp.gov.br/dataset/8da55b0e-b385-4b54-9296-d0000014ddd5/resource/39db5031-7238-4139-bcaa-e620a3180188/download/escolasr34fev2017.csv&quot;
download.file(url_cadatros_escolas, &quot;temp.csv&quot;)
</code></pre>

<p>Veja que baixar o arquivo diretamente no R é preferível ao processo manual, pois podemos rapidamente reproduzir o processo, além de documentá-lo. Vamos abrir o arquivo:</p>

<pre><code class="language-r">library(readr)
escolas &lt;- read_delim(&quot;temp.csv&quot;, delim = &quot;;&quot;)
</code></pre>

<p>Explore o arquivo com o comando <em>glimpse</em>:</p>

<pre><code class="language-r">library(dplyr)
glimpse(escolas)
</code></pre>

<p>Não há nada de extraordinário no arquivo, que se assemelha aos que vimos até então. Há, porém, uma dupla de variáveis que nos permite trabalhar &ldquo;geograficamente&rdquo; com o dado: LATITUDE e LONGITUDE. &ldquo;Lat e Long&rdquo; são a informação fundamental de um dos sistemas de coordenadas (coordinate reference system, CRS) mais utilizados para localização de objetos na superfície da terra.</p>

<p>Por uma razão desconhecida, a informação fornecida pela PMSP está em formato diferente do convenional. Latitudes são representadas por números entre -90 e 90, com 8 casas decimais, e Longitudes por números entre -180 e 180, também com 8 casas decimais. Em nosso par de variáveis, o separador de decimal está omitido e por esta razão faremos um pequena modificação na variável. Aproveitaremos também para renomear algumas variáveis de nosso interesse &ndash; como tipo da escola (CEI, EMEI, EMEF, CEU, etc) e o ano de início do funcionamento &ndash; e selecionaremos apenas as linhas referentes a EMEF (Escolas Municipal de Ensino Fundamental):</p>

<pre><code class="language-r">emef &lt;- escolas  %&gt;%
  rename(lat = LATITUDE, lon = LONGITUDE, tipo = TIPOESC) %&gt;% 
  mutate(lat = lat / 1000000, 
         lon = lon / 1000000,
         ano = as.numeric(substr(DT_INI_FUNC, 7, 10))) %&gt;%
  filter(tipo == &quot;EMEF&quot;)
</code></pre>

<p>Pronto! Temos agora uma informação geográfica das EMEFs e uma variável de interesse &ndash; ano &ndash; que utilizaremos para investigar a expansão da rede.</p>

<p>Vamos construir um primeiro mapa, usando a função que conhecemos &ndash; ggplot &ndash; a partir das informações de latitude e longitude das escolas:</p>

<pre><code class="language-r">library(ggplot2)
ggplot(aes(lon, lat), data = emef) +
  geom_point()
</code></pre>

<p>Veja que podemos &ldquo;imaginar&rdquo; o formato da cidade de São Paulo com os pontos, mas o mapa não é propriamente um mapa. Falta uma &ldquo;camada&rdquo; básica, sobre a qual os pontos serão desenhados.</p>

<p>Vamos utilizar o pacote <em>ggmap</em>, que é um pacote para visualização de dados espaciais com o pacote <em>ggplot2</em> para obter tal &ldquo;camada&rdquo;. Com a função <em>get_map</em>, faremos o download de um mapa que servirá de base para os pontos das EMEFs.</p>

<p>A função <em>get_map</em> requer como argumento principal um par de coordenadas a partir do qual o mapa será centralizado. No nosso exemplo vamos utilizar as coordenadas da Praça da Sé, que serão armazenadas em um vetor. É fácil obter coordenadas de um local a partir de serviços de localização na intenet.</p>

<pre><code class="language-r">library(ggmap)
se &lt;- c(lon = -46.6362714, lat = -23.5500806)
</code></pre>

<p>Com as coordenadas da Praça de Sé, vamos obter um mapa de São Paulo:</p>

<pre><code class="language-r">map_sp &lt;- get_map(se)
plot(map_sp)
</code></pre>

<p>Por padrão, <em>get_map</em> retorna um mapa de &ldquo;terreno&rdquo; e utiliza a API da Google, com zoom e escala automáticos.</p>

<p>Antes de alterar estes argumentos, vamos utilizar uma função &ldquo;irmã&rdquo; à <em>ggplot</em>, <em>ggmap</em>, para juntar o mapa de São Paulo com os pontos das escolas:</p>

<pre><code class="language-r">ggmap(map_sp) +
  geom_point(aes(lon, lat), data = emef)
</code></pre>

<p>Feio ainda, porém bastante mais informativo. Veja que combinamos duas fontes de dados: o cadastro da PMSP e um mapa obtido na API da Google.</p>

<p>Vamos obter mapas mais interessantes com <em>get_map</em>. Em primeiro lugar, podemos variar os tipos de mapas (argumento &ldquo;maptype&rdquo;) e obter qualquer um dentre as seguintes opções: &ldquo;terrain&rdquo;, &ldquo;terrain-background&rdquo;, &ldquo;satellite&rdquo;, &ldquo;roadmap&rdquo;, &ldquo;hybrid&rdquo;, &ldquo;toner&rdquo;, &ldquo;watercolor&rdquo;, &ldquo;terrain-labels&rdquo;, &ldquo;terrain-lines&rdquo;, &ldquo;toner-2010&rdquo;, &ldquo;toner-2011&rdquo;, &ldquo;toner-background&rdquo;, &ldquo;toner-hybrid&rdquo;, &ldquo;toner-labels&rdquo;, &ldquo;toner-lines&rdquo; e &ldquo;toner-lite&rdquo;.</p>

<p>Também podemos variar a API &ndash; argumento &ldquo;source&rdquo; &ndash; na qual o mapa será obtido: Google (&ldquo;google&rdquo;), Open Street Maps (&ldquo;osm&rdquo;) ou Stamen (&ldquo;stamen&rdquo;). Nem todas as &ldquo;source&rdquo; e &ldquo;maptypes&rdquo; podem ser combinados e os &ldquo;toner&rdquo; provêm da API Stamen.</p>

<p>Vejamos alguns exemplos (note o uso do operador &ldquo;pipe&rdquo;) abaixo:</p>

<pre><code class="language-r"># Terrain Google
get_map(se, source = &quot;google&quot;, maptype = &quot;terrain&quot;) %&gt;%
  ggmap() +
  geom_point(aes(lon, lat), data = emef)

# Roadmap Google
get_map(se, source = &quot;google&quot;, maptype = &quot;roadmap&quot;) %&gt;%
  ggmap() +
  geom_point(aes(lon, lat), data = emef)

# Toner Stamen
get_map(se, source = &quot;stamen&quot;, maptype = &quot;toner&quot;) %&gt;%
  ggmap() +
  geom_point(aes(lon, lat), data = emef)
</code></pre>

<p>Vamos alterar o zoom dos mapas e obter apenas mapas e ver o efeito:</p>

<pre><code class="language-r">get_map(se, source = &quot;google&quot;, maptype = &quot;roadmap&quot;, zoom = 6) %&gt;%
  ggmap() +
  geom_point(aes(lon, lat), data = emef)

get_map(se, source = &quot;google&quot;, maptype = &quot;roadmap&quot;, zoom = 10) %&gt;%
  ggmap() +
  geom_point(aes(lon, lat), data = emef)

get_map(se, source = &quot;google&quot;, maptype = &quot;roadmap&quot;, zoom = 11) %&gt;%
  ggmap() +
  geom_point(aes(lon, lat), data = emef)

get_map(se, source = &quot;google&quot;, maptype = &quot;roadmap&quot;, zoom = 14) %&gt;%
  ggmap() +
  geom_point(aes(lon, lat), data = emef)

get_map(se, source = &quot;google&quot;, maptype = &quot;roadmap&quot;, zoom = 18) %&gt;%
  ggmap() +
  geom_point(aes(lon, lat), data = emef)
</code></pre>

<p>Note que, quando estão fora da base, os pontos são descartados da visualização e obtemos um &ldquo;warning&rdquo;.</p>

<p>Convém, por conta da gramática da família de funções <em>ggplot</em>, definir uma camada básica na função <em>ggmap</em>, que, no nosso caso, são os pontos que estão em análise (e não a camada de mapa que (sic) dá base à visualização):</p>

<pre><code class="language-r">map_sp &lt;- get_map(se, source = &quot;google&quot;, maptype = &quot;roadmap&quot;, zoom = 11)
ggmap(map_sp, 
      base_layer = ggplot(aes(lon, lat), data = emef)) +
  geom_point()
</code></pre>

<p>Finalmente, vamos usar uma informação sobre as escolas para diferenciar os pontos. Os dados do cadastro não trazem informações muito interessantes sobre a escola e por isso utilizaremos o ano de criação. Em nosso desafio seguinte trabalharemos com informações sobre a escola que vêm de outra base do mesmo portal da prefeitura.</p>

<p>Introduziremos em nosso mapa uma escala de cores para diferenciar as EMEFs por ano de criação:</p>

<p>Nota: se você estiver com dificuldade em relação à gramática do <em>ggplot</em>, é sinal que pulou as últimas duas semanas e não leu os capítulos recomendados. Volte às aulas 6 e 7.</p>

<pre><code class="language-r">map_sp &lt;- get_map(se, source = &quot;google&quot;, maptype = &quot;roadmap&quot;, zoom = 12)
ggmap(map_sp, 
      base_layer = ggplot(aes(lon, lat, color = ano), data = emef)) +
  geom_point()
</code></pre>

<p>Como era de se esperar, os pontos mais claros na cidade estão nos extremos e as EMEFs mais antigas, e geral, nos bairros que consolidaram mais cedo no processo de urbanização.</p>

<h2 id="procurando-lat-e-long-com-o-pacote-ggmap">Procurando Lat e Long com o pacote ggmap</h2>

<p>E quando temos apenas o endereço dos locais que queremos encontrar? Bem, há alternativas oferecidas pelo próprio pacote <em>ggmap</em>.</p>

<p>Vamos agora criar um novo data frame a partir dos dados do cadastro da PMSP que contém apenas os CEUs. Vamos juntar todas as informações de endereço e agregar a elas o texto &ldquo;, Sao Paulo, Brazil&rdquo;</p>

<pre><code class="language-r">ceu &lt;- escolas  %&gt;%
  filter(TIPOESC == &quot;CEU&quot;) %&gt;%
  mutate(endereco = paste(ENDERECO, NUMERO, BAIRRO, CEP, &quot;, Sao Paulo, Brazil&quot;))
</code></pre>

<p>Com a função <em>geocode</em>, procuraremos a latitude e longitude dos 46 CEUs. Vamos ver o exemplo do primeiro CEU:</p>

<pre><code class="language-r">ceu1 &lt;- geocode(ceu$endereco[1])
ggmap(map_sp, 
      base_layer = ggplot(aes(lon, lat), data = ceu1)) +
  geom_point()
</code></pre>

<p>Usando o que já havíamos visto, obtivemos um mapa com um único ponto. De fato, se procurarmos a informação deste CEU (CEU Alvarenga), veremos que obtivemos a latitude e longitude corretas.</p>

<p>Com um <em>for loop</em>, procuraremos a latitude e longitude dos 46 endereços:</p>

<pre><code class="language-r"># Para remover problemas com enconding, removi algumas observacoes usando
# as linhas marcadas como comentario abaixo. No Windows pode ser desnecessario
ceu$endereco &lt;- iconv(ceu$endereco, to = &quot;ASCII//TRANSLIT&quot;)
ceu &lt;- ceu[!is.na(ceu$endereco),]
latlong &lt;- data.frame()
for (i in 1:nrow(ceu)){
  latlong &lt;- bind_rows(latlong, geocode(ceu$endereco[i]))
}

ceu &lt;- bind_cols(ceu, latlong)
</code></pre>

<p>Simples, não! O principal problema da função <em>geocode</em> é que há um limite de consultas por conta dos termos da Google Maps API. A alternativa é usar como argumento &ldquo;source = &lsquo;dsk&rsquo;&rdquo; <a href="http://www.datasciencetoolkit.org/about">Data Science Toolkit</a>, que reune uma série de fontes de dados e utiliza outra API para a consulta de latitude e longitude de logradouros.</p>

<p>Vamos agora elaborar um mapa com os pontos obtidos para cada CEU:</p>

<pre><code class="language-r">ggmap(map_sp, 
      base_layer = ggplot(aes(lon, lat), data = ceu)) +
  geom_point()
</code></pre>

<h2 id="pontos-linhas-polígonos-e-classes-sp">Pontos, linhas, polígonos e classes sp</h2>

<p>Em nossos exemplos utilizamos <em>data frames</em> para armazenar as infomações espaciais. Isso foi possível por que, ao trabalharmos com latitude e longitude de pontos, ficamos limitados a um único sistema de coordenadas e tampouco precisamos de mais de uma linha do data frame para armazenar o &ldquo;desenho&rdquo; de um objeto (ponto) em um mapa.</p>

<p>Há vários sistemas de coordenadas utilizados em diferentes bases de dados cartográficas. Assim, por um lado, precisamos de métodos que nos permitam transformar um sistema em outro para combinar diferentes fontes de dados. Dados especiais armazenados em data frames não contêm referência alguma ao sistema de coordenadas ao qual pertencem.</p>

<p>Por outro lado, se precisarmos de mapas que incluem outras representações geométricas, como linhas e pontos, somos obrigados a multiplicar o número de linhas em um data frame pelo número de vértices de tais figuras (2 vezes para uma linha e <em>n</em> vezes para um polígono, onde <em>n</em> é o número de vértices do polígono). Esse método, ainda que possível, é muito ineficiente.</p>

<p>A solução é trabalharmos com classes de objetos mais complexas (e completas) do que data frames. Vamos falar sobre isso ao explorarmos as principais classes do pacote <em>sp</em>. Em nosso tutorial vamos trabalhar com as classes de objetos do pacote <em>sp</em> e om as funções disponíveis para sua manipulação.</p>

<p>Antes disso, poré, vamos conhecer o formato mais comum para armazenar dados espaciais &ndash; <em>shapefile</em> &ndash; e como abrí-los em R.</p>

<h3 id="shapefiles">Shapefiles</h3>

<pre><code class="language-r">library(sp)
</code></pre>

<p>Ademais de precisarmos de outras classes de objetos em R para armazenarmos informação espacial, precisamos também de formatos de arquivos diferentes para compartilhar dados espaciais. <em>Shapefiles</em> são os mais populares e diversos repositórios de dados espaciais, como a <a href="http://www.prefeitura.sp.gov.br/cidade/secretarias/urbanismo/dados_estatisticos/index.php?p=160798">Prefeitura de São Paulo</a> e
o <a href="http://www.fflch.usp.br/centrodametropole/">Centro de Estudos da Metrópole (CEM)</a>.</p>

<p>Nosso primeiro exemplo foi retirado do site do CEM e ligeiramente modificado. Sugiro que você dê uma olhada nas bases cartográficas do CEM, pois há bastante coisa interessante lá.</p>

<p>Vamos começar fazendo o download do arquivo .zip onde estão os dados:</p>

<pre><code class="language-r">url_shp_eleicoes_sp &lt;- &quot;https://github.com/leobarone/FLS6397/raw/master/data/rmsp.zip&quot;
download.file(url_shp_eleicoes_sp, &quot;temp.zip&quot;)
unzip(&quot;temp.zip&quot;)
</code></pre>

<p>Veja que o arquivo descompactado é uma pasta (&ldquo;rmsp&rdquo;) com arquivos de diversas extensões. Não vamos entrar nos detalhes dos arquivos. Quando falamos de &ldquo;shapefile&rdquo;, estamos nos referindo a arquivos .shp. Mas raramente ele vem desacompanhado. A informação que nos importa é: todos eles, exceto, obviamente, o arquivo em .pdf, farão parte do objeto que criaremos.</p>

<pre><code class="language-r">list.files(&quot;rmsp&quot;)
</code></pre>

<p>É fundamental que os arquivos de diferentes extensões tenham o mesmo nome, inclusive maiúsculas e minúsculas, e que os nomes das extensões estejam em letras minúsculas. Por esta razão, tome cuidado ao usar os arquivos do CEM e da PMSP, pois, em geral, algum arquivo vem com o nome e extensão em letras maiúscula.</p>

<p>A biblioteca para abertura de dados espaciais em R é <em>rgdal</em>. <em>readORG</em>, função de <em>rgdal</em> que utilizaremos para abrir os dados, recebe dois argumentos: a pasta em que estão os arquivos &ndash; no nosso caso &ldquo;rmsp&rdquo;, e o nome dos arquivos sem extensão (e por esta razão é fundamental que tenham o mesmo nome):</p>

<pre><code class="language-r">library(rgdal)
rmsp &lt;- readOGR(&quot;rmsp&quot;, &quot;MunRM07&quot;)
</code></pre>

<p>Vamos observar a classe do objeto importado:</p>

<pre><code class="language-r">class(rmsp)
</code></pre>

<p>&ldquo;SpatialPolygonsDataFrame&rdquo; é, como é fácil deduzir, um objeto espacial que contém polígonos (municípios da Região Metropolitana de São Paulo) e que acompanha um data frame. Falaremos sobre essa classe de objetos a seguir.</p>

<p>Tal classe de objetos pode ser rapidamente visualizada utilizando o comando <em>plot</em>:</p>

<pre><code class="language-r">plot(rmsp)
</code></pre>

<p>Podemos utilizar o pacote <em>ggplot2</em> e sua gramática para plotar objetos da classe &ldquo;SpatialPolygonsDataFrame&rdquo;:</p>

<pre><code class="language-r">ggplot(data = rmsp, 
       aes(x = long, y = lat, group = group)) + 
  geom_polygon(color = 'white', fill = 'darkgrey') +
  coord_map()
</code></pre>

<h4 id="exercício">Exercício:</h4>

<p>Vá a uma das duas fontes de mapas indicadas &ndash; <a href="http://www.prefeitura.sp.gov.br/cidade/secretarias/urbanismo/dados_estatisticos/index.php?p=160798">Prefeitura de São Paulo</a> ou  <a href="http://www.fflch.usp.br/centrodametropole/">Centro de Estudos da Metrópole (CEM)</a> &ndash; importe os dados e produza um mapa. Dependendo do tema que você escolher, você produzirá mapas com polígonos (por exemplo, mapas de divisões políticas ou administrativas), linhas (ruas, ciclovias, etc) ou pontos (unidades de saúde, escolas, etc).</p>

<h2 id="classes-do-pacote-sp-e-data-frames">Classes do pacote sp e data frames</h2>

<p>Se nosso objetivo fosse apenas importar os dados e produzir um mapa, poderíamos para na sessão anterior. Contudo, a regra é tentarmos combinar bases de dados espaciais entre si ou com data frames que contém informações não presentes no arquivos que acompanham o &ldquo;shapefile&rdquo;. No Desafio 4, adicionaremos informações geradas no Desafio 3 ao mapa que acabamos de produzir com municípios da região metropolitana, por exemplo.</p>

<p>Como combinar dois &ldquo;SpatialPolygonsDataFrame&rdquo; com sistemas coordenadas diferentes? Como relacionar um data frame a um objeto da classe &ldquo;SpatialPolygonsDataFrame&rdquo;?</p>

<p>Vamos conhecer o que há dentro de um &ldquo;SpatialPolygonsDataFrame&rdquo; com a função <em>str</em>. Para não poluir o console, vamos adicionar o argumento &ldquo;max.level = 2&rdquo;:</p>

<pre><code class="language-r">str(rmsp, max.level = 2)
</code></pre>

<p>Um &ldquo;SpatialPolygonsDataFrame&rdquo; contém vários elementos. O principal deles são, obviamente, os polígonos. Para o objeto &ldquo;rmsp&rdquo;, são 39 polígonos. Já entraremos no detalhe de cada um. &ldquo;plotOrder&rdquo; e &ldquo;bbox&rdquo; são elementos do objeto que definem, respectivamente, a ordem de &ldquo;plotagem&rdquo; e as dimensões de um retângulo que contém todos os polígonos e raramente nos importaremos cm ambos.</p>

<p>&ldquo;proj4string&rdquo; armazena a informação sobre qual é sistema de coordenadas ao qual as coordenadas dos polígonos pertencem.</p>

<p>Um objeto da classe &ldquo;SpatialPolygons&rdquo; contém estes quatro elementos. Os objetos &ldquo;SpatialPolygonsDataFrame&rdquo; são iguais aos &ldquo;SpatialPolygons&rdquo; com a adição do elemento @data.</p>

<p>&ldquo;SpatialLines&rdquo;, &ldquo;SpatialLinesDataFrame&rdquo;, &ldquo;SpatialMultiPoints&rdquo; e &ldquo;SpatialMultiPointsDataFrame&rdquo; são as classes correspondentes para linhas e pontos e tem estrutura semelhante.</p>

<p>Podemos selecionar um elemento da estrutura de um objeto das classes do pacote <em>sp</em> usando o símbolo \@. Vamos separar o objeto &ldquo;rmsp&rdquo; em 3 novos objetos:</p>

<pre><code class="language-r">rmsp_data &lt;- rmsp@data
rmsp_poligonos &lt;- rmsp@polygons
rmsp_projecao &lt;- rmsp@proj4string
</code></pre>

<p>&ldquo;rmsp_data&rdquo; é um data frame com os dados dos municípios:</p>

<pre><code class="language-r">head(rmsp_data)
</code></pre>

<p>&ldquo;rmsp_projecao&rdquo; é um</p>

<p>Conhecendo a estrutura de tais classes, já temos uma pista do que precisamos para (1) colocar duas projeções no mesmo sistema de coordenadas (alterando a informação sobre projeção) e (2) adicionar dados proveninentes de um data frame (combinando-o com o que estiverm em \@data). Faremos este último a seguir e não cobriremos o primeiro. Antes disso, vamos entender a complexa estrutura dos elementos em @polygons.</p>

<p>Vamos criar o objeto &ldquo;poligono1&rdquo; com o primeiro elemento de &ldquo;rmsp_poligonos&rdquo; e examiná-lo.</p>

<pre><code class="language-r">poligono1 &lt;- rmsp_poligonos[[1]]
str(poligono1)
</code></pre>

<p>Note que ele é da classe &ldquo;Polygons&rdquo;, também do pacote <em>sp</em>. Um polígono contém várias informações: os vértices do polígono; as conexões entre os vértices; a existências de &ldquo;buracos&rdquo; no polígono (que o buraco é também um polígono e polígonos com buracos lembram rosquinhas); etc. Não vamos examinar o que há em cada polígono, mas você já deve ter percebido que &ldquo;SpatialPolygons&rdquo; e &ldquo;SpatialPolygonsDataFrame&rdquo; são conjuntos de &ldquo;Polygons&rdquo; com algumas informações adicionais (dentre as quais um data frame com características de cada polígono no caso do último). &ldquo;SpatialPoints&rdquo; e &ldquo;Lines&rdquo; são classes análogas.</p>

<p>A não se que você deseje criar novos (ou redesenhar) polígonos, não convém examinar essa classe de objetos.</p>

<h3 id="particionando-um-objeto-de-dados-espaciais">Particionando um objeto de dados espaciais</h3>

<p>Eventualmente, não são todos os polígonos importados de um &ldquo;shapefile&rdquo; que interessam. As classes do pacote <em>sp</em> aceitam seleção de polígonos da mesma forma que os data frames. No objeto &ldquo;rmsp&rdquo;, São Paulo é o 12o município, como vemos pelo vetor de nomes dos municípios em &ldquo;rmsp_data&rdquo;:</p>

<pre><code class="language-r">rmsp_data$NOME
</code></pre>

<p>Podemos separar o polígono de São Paulo e criar seu mapa da seguinte forma:</p>

<pre><code class="language-r">saopaulo &lt;- rmsp[12,]
plot(saopaulo)
</code></pre>

<p>Repetindo o exemplo, mas para os 3 municípios do ABC:</p>

<pre><code class="language-r">posicoes_abc &lt;- c(11, 15, 30)
abc &lt;- rmsp[posicoes_abc,]
plot(abc)
</code></pre>

<p>Examinando a estrutura de &ldquo;abc&rdquo; notamos que o conjunto de polígonos e o data frame contém agora apenas 3 observações, como esperávamos.</p>

<pre><code class="language-r">str(abc, max.level = 2)
</code></pre>

<h3 id="agregando-e-visualizando-características-de-objetos-espaciais">Agregando e visualizando características de objetos espaciais</h3>

<p>Vamos voltar ao nosso mapa da Região Metropolitana de São Paulo:</p>

<pre><code class="language-r">plot(rmsp)
</code></pre>

<p>Bastante sem graça, certo? Não estamos aprensentando nenhuma característica dos municipios no mapa, apenas os polígonos que os definem.</p>

<p>Os dados que acompanham o &ldquo;shapefile&rdquo;, porém, nos apresentam uma característica interessante dos munípios: a densidade demográfica (&ldquo;DENS_DEMO&rdquo;)</p>

<pre><code class="language-r">head(rmsp@data)
</code></pre>

<p>Vamos repetir o mapa, colorindo os municípios de acordo com a densidade demográfica:</p>

<pre><code class="language-r">plot(rmsp, col = log(rmsp@data$DENS_DEMO))
</code></pre>

<p>Não muito bonito, mas bastante mais interessante. Vamos trazer uma variável externa aos dados para tornar nosso exemplo mais atraente. Utilizaremos os dados de planejamento urbano da MUNIC-IBGE 2015. Note que, por parcimônia, não estamos buscando os dados diretamente na fonte, mas em uma cópia dos dados no repositório do curso.</p>

<p>No nosso exemplo buscaremos o ano de elaboração do plano diretor de cada município da RMSP nas informações sobre planejamento urbano. Separaremos esta variável de interesse e o código do município, ambas variáveis jpa renomeadas:</p>

<pre><code class="language-r">url_munic_15 &lt;- &quot;https://raw.githubusercontent.com/leobarone/FLS6397/master/data/planejamento_munic_2015.csv&quot;
munic_15 &lt;- read.table(url_munic_15, header = T, sep = &quot;;&quot;) %&gt;%
  rename(COD_IBGE = A1, ano_pd = A18) %&gt;%
  select(COD_IBGE, ano_pd) %&gt;%
  mutate(ano_pd = as.numeric(as.character(ano_pd)))
</code></pre>

<p>Para adicioanrmos essa informação ao objeto de dados espaciais, basta fazermos um <em>left_join</em> com os dados em \@data:</p>

<pre><code class="language-r">rmsp@data &lt;- rmsp@data %&gt;% 
  left_join(munic_15, by = &quot;COD_IBGE&quot;)
</code></pre>

<p>Nada de novo, exceto o fato de que o data frame está dentro de um objeto mais complexo. Vamos agora plotar o ano de elaboração dos Planos Diretores de cada município como cores nos mapas:</p>

<pre><code class="language-r">plot(rmsp, col = factor(rmsp@data$ano_pd))
</code></pre>

<p>De novo, bastante feio, mas conseguimos trazer rapidamente dados de uma fonte externa para nosso mapa.</p>

<h3 id="deixando-o-mapa-bonito-com-ggplot2">Deixando o mapa bonito com <em>ggplot2</em></h3>

<p>Vimos anterioremente que podemos plotar mapas usando o pacote <em>ggplot2</em>. Vejamos o mpa básico:</p>

<pre><code class="language-r">ggplot(data = rmsp, 
       aes(x = long, y = lat, group = group)) + 
  geom_polygon(color = 'white', fill = 'darkgrey') +
  coord_map()
</code></pre>

<p>Para adicionarmos novas variáveis utilizando o <em>ggplot2</em>, porém, precisamos reorganizar nossos dados. Infelizmente, se simplemente adicionarmos uma variável que esteja em \@data ao argumento &ldquo;fill&rdquo;, por exemplo, obteremos um mensagem de erro.</p>

<p>A solução será reorganizar os dados de polígonos em um data frame novo com a função <em>fortify</em>, perdendo justamente a eficiência que as classes de objetos do pacote <em>sp</em> forneceram.</p>

<p>Na sequência abaixo, criaremos &ldquo;rmsp_df&rdquo; com a função fortify. &ldquo;rmsp_df&rdquo; terá apenas variáveis &ldquo;espaciais&rdquo;. Para adicionar as demais variáveis que estão em \@data, teremos de criar um &ldquo;id&rdquo; comum a ambos os data frames e realizar um <em>left_join</em>:</p>

<pre><code class="language-r">rmsp_df &lt;- fortify(rmsp)
rmsp_df$id &lt;- as.numeric(rmsp_df$id)
rmsp@data$id &lt;- 0:(nrow(rmsp@data)-1)
rmsp_df &lt;- left_join(rmsp_df, rmsp@data, by = &quot;id&quot;)
</code></pre>

<p>Observemos o objeto &ldquo;rmsp_df&rdquo;:</p>

<pre><code class="language-r">glimpse(rmsp_df)
</code></pre>

<p>Note que todas as variáveis que precisamos estão aí. Reorganizando os argumentos do nosso mapa anterior, produzido com <em>ggplot</em>, podemos gerar mapas bastante mais elegantes. O primeiro, usando a informação sobre densidade demográfica:</p>

<pre><code class="language-r">ggplot(data = rmsp_df, 
       aes(x = long, y = lat, group = group, fill = DENS_DEMO)) + 
  geom_polygon() +
  coord_map()
</code></pre>

<p>E agora o ano dos planos diretores, variável que contém um número grande de missing values para os municípios da RMSP:</p>

<pre><code class="language-r">ggplot(data = rmsp_df, 
       aes(x = long, y = lat, group = group, fill = ano_pd)) + 
  geom_polygon() +
  coord_map()
</code></pre>

<p>A grande vantagem de trabalharmos com a gramática do <em>ggplot2</em> é que podemos editar os mapas da mesma forma que editamos gráficos e as possibilidades são inúmeras.</p>


			<aside class="copyright" role="note">
				
				&copy; 2018 Released under the MIT license &ndash;
				
				Documentation built with
				<a href="https://www.gohugo.io" target="_blank">Hugo</a>
				using the
				<a href="http://github.com/digitalcraftsman/hugo-material-docs" target="_blank">Material</a> theme.
			</aside>

			<footer class="footer">
				

<nav class="pagination" aria-label="Footer">
  <div class="previous">
  
      <a href="../tutorial5/" title="Manipulação de Dados">
        <span class="direction">
          Previous
        </span>
        <div class="page">
          <div class="button button-previous" role="button" aria-label="Previous">
            <i class="icon icon-back"></i>
          </div>
          <div class="stretch">
            <div class="title">
              Manipulação de Dados
            </div>
          </div>
        </div>
      </a>
  
  </div>

  <div class="next">
  
      <a href="../tutorial9/" title="MySQL e Dplyr">
        <span class="direction">
          Next
        </span>
        <div class="page">
          <div class="stretch">
            <div class="title">
              MySQL e Dplyr
            </div>
          </div>
          <div class="button button-next" role="button" aria-label="Next">
            <i class="icon icon-forward"></i>
          </div>
        </div>
      </a>
  
  </div>
</nav>





			</footer>
		</div>
	</article>

	<div class="results" role="status" aria-live="polite">
		<div class="scrollable">
			<div class="wrapper">
				<div class="meta"></div>
				<div class="list"></div>
			</div>
		</div>
	</div>
</main>

    <script>
    
      var base_url = '\/';
      var repo_id  = 'R4CS\/site';
    
    </script>

    <script src="../javascripts/application.js"></script>
    

    <script>
      /* Add headers to scrollspy */
      var headers   = document.getElementsByTagName("h2");
      var scrollspy = document.getElementById('scrollspy');

      if(scrollspy) {
        if(headers.length > 0) {
          for(var i = 0; i < headers.length; i++) {
            var li = document.createElement("li");
            li.setAttribute("class", "anchor");

            var a  = document.createElement("a");
            a.setAttribute("href", "#" + headers[i].id);
            a.setAttribute("title", headers[i].innerHTML);
            a.innerHTML = headers[i].innerHTML;

            li.appendChild(a)
            scrollspy.appendChild(li);
          }
        } else {
          scrollspy.parentElement.removeChild(scrollspy)
        }


        /* Add permanent link next to the headers */
        var headers = document.querySelectorAll("h1, h2, h3, h4, h5, h6");

        for(var i = 0; i < headers.length; i++) {
            var a = document.createElement("a");
            a.setAttribute("class", "headerlink");
            a.setAttribute("href", "#" + headers[i].id);
            a.setAttribute("title", "Permanent link")
            a.innerHTML = "#";
            headers[i].appendChild(a);
        }
      }
    </script>

    

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>

